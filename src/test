
import React, { useState,useEffect } from 'react'
import { Paper, Typography, TextField, Container, Grid } from '@material-ui/core'
import { makeStyles } from '@material-ui/core'
import InputUnit from './InputUnit';
import '../App.css'
import { Specs,Environment,Diameter } from '../data/data';


const InputContainer=()=> {

    const[specs,setSpecs]=useState(Specs)
    const[environment,setEnvironment]=useState(Environment)
    const[diameter,setDiameter]=useState(Diameter)

    // useEffect(()=>{

    //     specsChangeHandler(specs,data)
    //     environmentChangeHandler()
    //     diameterChangeHandler()
    // },[])

   const specsChangeHandler = (e, data) => {
        // console.log(e.target.value, data.id);

        //copy the input object from the state
        const updatedInput = { ...specs.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

         //The data is calculated for certain required fields 

         updatedInput.nominalVoltage.value=updatedInput.cellsInSeries.value*3.7

         updatedInput.maxRPM.value=(updatedInput.kvRating.value*updatedInput.nominalVoltage.value)
         updatedInput.maxWorkingRPM.value=(updatedInput.estimatedMaxPercent.value)/100*updatedInput.maxRPM.value
 
    
        //set the new state
        setSpecs({ input: updatedInput });



    }
  
    const environmentChangeHandler = (e, data) => {
        // console.log(e.target.value, data.id);

        //copy the input object from the state
        const updatedInput = { ...environment.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

        //set the new state
        setEnvironment({ input: updatedInput });
    }

    const diameterChangeHandler = (e, data) => {
        // console.log(e.target.value, data.id);

        //copy the input object from the state
        const updatedInput = { ...diameter.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

           //Diameter1 value calculation start
         // let powerData=(updatedInput.cp1.value*updatedInput.density.value*Math.pow(updatedInput.maxWorkingRPM.value/60,3))
         let diameter1Result=Math.pow((specs.input.maxPower.value/(updatedInput.cp1.value*environment.input.density.value* Math.pow((specs.input.maxWorkingRPM.value/60),3))),1/5)*1000/25.4
         let diameter2Result=Math.pow((specs.input.maxPower.value/(updatedInput.cp2.value*environment.input.density.value* Math.pow((specs.input.maxWorkingRPM.value/60),3))),1/5)*1000/25.4
        console.log(specs.input.kvRating.value,"specsvalue")
        console.log(environment.input.density.value,"envirovalue")
        console.log(updatedInput.cp2.value,"diametervalue")
        console.log(updatedInput.cp1.value,"diameter1value")
 
         updatedInput.diameter1.value=diameter1Result
         updatedInput.diameter2.value=diameter2Result
 

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

        //set the new state
        setDiameter({ input: updatedInput });
    }


    
        let specsInputData = []
        for (let key in specs.input) {
            specsInputData.push({ id: key, data: specs.input[key] })
        }
        let environmentInputData = []
        for (let key in environment.input) {
            environmentInputData.push({ id: key, data: environment.input[key] })
        }
        let diameterInputData = []
        for (let key in diameter.input) {
            diameterInputData.push({ id: key, data: diameter.input[key] })
        }

        useEffect(
            ()=>{
                
                const updatedDiameterInput = { ...diameter.input }
                const updatedEnvironmentInput={...environment.input}
                const updatedSpecsInput={...specs.input}

                let diameter1Result=Math.pow((updatedSpecsInput.maxPower.value/(updatedDiameterInput.cp1.value*updatedEnvironmentInput.density.value* Math.pow((updatedSpecsInput.maxWorkingRPM.value/60),3))),1/5)*1000/25.4

                let diameter2Result=Math.pow((updatedSpecsInput.maxPower.value/(updatedDiameterInput.cp2.value*updatedEnvironmentInput.density.value* Math.pow((updatedSpecsInput.maxWorkingRPM.value/60),3))),1/5)*1000/25.4
                    updatedDiameterInput.diameter1.value=diameter1Result
                    updatedDiameterInput.diameter2.value=diameter2Result
                    // copy the specific field like density, maxPower using data.id from updatedInput
                    setDiameter({ input: updatedDiameterInput });
                    console.log("updated diameter")
            
                    },[specs])
        console.log('specsData',specsInputData,'environmentData:',environmentInputData,'diameterData', diameterInputData)
        // const classes = useStyles();
        console.log(specs,"state")
        return (
            <div style={{ margin: '0px 20px' }}>

                <div style={{marginTop: '20px'}}>
                    <Typography variant='h5' style={{ margin: '12px', textAlign: 'center' }} >Specs</Typography>
                    <div style={{ flexGrow: 1 }}>
                        <Paper className="paper" style={{ padding: '20px 30px' }}>
                            <Grid container spacing={0}>


                                {specsInputData.map(eachInputData => {
                                    return (
                                        <Grid item xs={6}>
                                            <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => specsChangeHandler(e, eachInputData)} />
                                        </Grid>
                                    )
                                })}

                            </Grid>
                        </Paper>
                    </div>
                </div>
                <div style={{margin: '20px 0px'}}>
                    <Typography variant='h5' style={{ margin: '12px', textAlign: 'center' }} >Environment</Typography>

                    <Paper className="paper" style={{ padding: '0px 20px' }}>
                        <Grid container>
                            {environmentInputData.map(eachInputData => {
                                return (
                                    <Grid item xs={6} md={6} lg={6}>
                                        <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => environmentChangeHandler(e, eachInputData)} />
                                    </Grid>
                                )
                            })}
                        </Grid>
                    </Paper>
                </div>

                <div style={{margin: '20px 0px'}}>
                    <Typography variant='h5' style={{ margin: '12px', textAlign: 'center' }} >Propeller and Diameter Selection</Typography>

                    <Paper className="paper" style={{ padding: '0px 20px' }}>
                        <Grid container>
                            {diameterInputData.map(eachInputData => {
                                return (
                                    <Grid item xs={6} md={6} lg={6}>
                                        <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => diameterChangeHandler(e, eachInputData)} />
                                    </Grid>
                                )
                            })}
                        </Grid>
                    </Paper>
                </div>
            </div>
        )
    }

export default InputContainer;


const sizing={
    missionRequirement:{
        range:{
            value:108,
            unit:'km',
            input:true,
            field:'Range',
            name:'range'
        },
        flightTime:{
            value:1.24,
            unit:'hr',
            input:true,
            field:'Flight Time',
            name:'flightTime'
        },
        payload:{
            value:1.5,
            unit:'kg',
            input:true,
            field:'Payload',
            name:'payload'
        }
    },
    operatingEnvironment:{
        altitude:{
            value:2500,
            unit:'m',
            input:true,
            field:'Altitude',
            name:'altitude'
        },
        airDensity:{
            value:0.9,
            unit:'kg/m^3',
            input:true,
            field:'Air Density',
            name:'airDensity'
        },
        acceleration:{
            value:9.81,
            unit:'m/s^2',
            input:false,
            field:'Acceleration',
            name:'acceleration'
        },
        cruiseSpeed:{
            value:20,
            unit:'m/s',
            input:true,
            field:'Cruise Speed',
            name:'cruiseSpeed'
        },
        stallSpeed:{
            value:15,
            unit:'m/s',
            input:true,
            field:'Stall Speed',
            name:'stallSpeed'
        }
    },
    mass:{
        totalMass:{
            value:12,
            unit:'kg',
            input:true,
            field:'Total Mass',
            name:'totalMass'
        },
        batteryMass:{
            value:3.85,
            unit:'kg',
            input:true,
            field:'Battery Mass',
            name:'batteryMass'
        }
    },
    Wing:{
        span:{
            value:2.6,
            unit:'m',
            input:true,
            field:'Wing',
            name:'wing'
        },
        aspectRatio:{
            value:8,
            unit:'',
            input:true,
            field:'Aspect ratio',
            name:'aspectRatio'
        },
        inducedDragFactor:{
            value:0.04,
            input:true,
            unit:"",
            field:'Induced Drag Factor',
            name:"inducedDragFactor"
        },
        tapperRatio:{
            value:0.04,
            unit:'',
            input:true,
            field:'Tapper Ratio',
            name:'tapperRatio'
        }
    }
}









let data=sizingArray.map((parent,index)=>{
    
    console.log(parent,"parent")
// return <h1>Header</h1>
let arr=
parent.data.map((child,index)=>{
    
console.log(child.data,'parentchild')
return(
    <Grid  items xs={6} style={{margin:'20px 0'}} >
    <Paper elevation={4} className="paper" style={{ padding: '20px 30px',marginLeft:' 20px',marginRight:'10px' }}>
        <div style={{marginTop: '20px'}}>
           <Typography variant='h5' style={{ marginBottom: '12px', textAlign: 'center' }} >Motor Specs</Typography>
                <div style={{ flexGrow: 1 }}>        
                       <Grid item xs={12}>
         <InputUnit key={child.data.name} id={child.data.name} data={child.data} onchange={(e)=>sizingChangeHandler(e,child.data)} />
                           {/* <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => sizingChangeHandler(e, eachInputData.data)} /> */}
                       </Grid>
                   </div>         
                  </div>
             </Paper>
           </Grid>
    )

})
return arr
})


console.log(data,"datta")



 //copy the input object from the state
        const updatedInput = { ...specs.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

         //The data is calculated for certain required fields 

         updatedInput.nominalVoltage.value=updatedInput.cellsInSeries.value*3.7

         updatedInput.maxRPM.value=(updatedInput.kvRating.value*updatedInput.nominalVoltage.value)
         updatedInput.maxWorkingRPM.value=(updatedInput.estimatedMaxPercent.value)/100*updatedInput.maxRPM.value

 
         console.log(updatedInput.kvRating.value,"kvcheck")
    
        //set the new state
        setSpecs({ input: updatedInput });




updatedSizing.calculatedWing.wingArea.value=Math.pow(updatedSizing.wing.span.value,2)/updatedSizing.wing.aspectRatio.value;
    updatedSizing.calculatedWing.rootChord.value=2*updatedSizing.calculatedWing.wingArea.value/(updatedSizing.wing.span.value*(1+updatedSizing.wing.tapperRatio.value));
    updatedSizing.calculatedWing.tipChord.value=(updatedSizing.calculatedWing.rootChord.value*updatedSizing.wing.tapperRatio.value);
     updatedSizing.calculatedWing.meanAerodynamicChord.value=(1+updatedSizing.wing.tapperRatio.value+Math.pow(updatedSizing.wing.tapperRatio.value,2))/(1+updatedSizing.wing.tapperRatio.value)*2/3*updatedSizing.calculatedWing.rootChord.value;
     updatedSizing.calculatedHorizontalTail.sht.value=updatedSizing.horizontalTail.cht.value*updatedSizing.calculatedWing.wingArea.value*updatedSizing.calculatedWing.meanAerodynamicChord.value/updatedSizing.horizontalTail.lht.value;
     updatedSizing.calculatedHorizontalTail.rootChord.value=(2*updatedSizing.calculatedHorizontalTail.sht.value/updatedSizing.horizontalTail.span.value)/(1+updatedSizing.horizontalTail.tapperRatio.value);
     updatedSizing.calculatedHorizontalTail.tipChord.value=updatedSizing.calculatedHorizontalTail.rootChord.value*updatedSizing.horizontalTail.tapperRatio.value;
     updatedSizing.calculatedVerticalTail.svt.value=updatedSizing.calculatedWing.wingArea.value*updatedSizing.wing.span.value*updatedSizing.verticalTail.cvt.value/updatedSizing.verticalTail.lvt.value;
     updatedSizing.calculatedVerticalTail.rootChord.value=(updatedSizing.calculatedVerticalTail.svt.value*2/updatedSizing.verticalTail.span.value)/(1+updatedSizing.verticalTail.tapperRatio.value);
     updatedSizing.calculatedVerticalTail.tipChord.value=updatedSizing.calculatedVerticalTail.rootChord.value*updatedSizing.verticalTail.tapperRatio.value;
     updatedSizing.general.massFraction.value=(updatedSizing.missionRequirement.payload.value+updatedSizing.mass.batteryMass.value)/updatedSizing.mass.totalMass.value*100;
     updatedSizing.general.ostwaldEfficiency.value=1/(1+updatedSizing.wing.inducedDragFactor.value)
     updatedSizing.general.k.value=1/(3.14*updatedSizing.general.ostwaldEfficiency.value*updatedSizing.wing.aspectRatio.value)
     updatedSizing.general.minDragAirspeed.value=Math.pow((2*updatedSizing.mass.totalMass.value*updatedSizing.operatingEnvironment.acceleration.value/(updatedSizing.operatingEnvironment.airDensity.value*updatedSizing.calculatedWing.wingArea.value)),0.5)*Math.pow((updatedSizing.general.k.value/(updatedSizing.drag.wingZeroLiftDragCoefficient.value+updatedSizing.drag.fuselageDragCoefficient.value)),0.25);
     updatedSizing.general.minPowerAirspeed.value=Math.pow(1/(3),0.25)*updatedSizing.general.minDragAirspeed.value;
     updatedSizing.general.maxLiftCoefficient.value=updatedSizing.mass.totalMass.value*updatedSizing.operatingEnvironment.acceleration.value/(0.5*updatedSizing.operatingEnvironment.airDensity.value*Math.pow(updatedSizing.operatingEnvironment.stallSpeed.value,2)*updatedSizing.calculatedWing.wingArea.value);
     updatedSizing.general.designLiftCoefficient.value=updatedSizing.mass.totalMass.value*updatedSizing.operatingEnvironment.acceleration.value/(0.5*updatedSizing.operatingEnvironment.airDensity.value*Math.pow(updatedSizing.operatingEnvironment.cruiseSpeed.value,2)*updatedSizing.calculatedWing.wingArea.value);
     updatedSizing.general.inducedDragCoefficient.value=updatedSizing.general.k.value*Math.pow(updatedSizing.general.designLiftCoefficient.value,2)
     updatedSizing.general.totalDragCoefficient.value=updatedSizing.drag.wingZeroLiftDragCoefficient.value+updatedSizing.drag.fuselageDragCoefficient.value+updatedSizing.general.inducedDragCoefficient.value;
     updatedSizing.general.drag.value=(0.5*updatedSizing.operatingEnvironment.airDensity.value*Math.pow(updatedSizing.operatingEnvironment.cruiseSpeed.value,2)*updatedSizing.calculatedWing.wingArea.value*(updatedSizing.general.totalDragCoefficient.value)/updatedSizing.operatingEnvironment.acceleration.value)
     updatedSizing.general.liftToDragRatio.value=updatedSizing.general.designLiftCoefficient.value/updatedSizing.general.inducedDragCoefficient.value;
     updatedSizing.motorAndBattery.maxPower.value=updatedSizing.mass.totalMass.value*updatedSizing.motorAndBattery.powerToWeightRatio.value;
     updatedSizing.motorAndBattery.powerCruise.value=updatedSizing.general.drag.value*updatedSizing.operatingEnvironment.acceleration.value*updatedSizing.operatingEnvironment.cruiseSpeed.value;
     updatedSizing.motorAndBattery.currentCruise.value=(updatedSizing.motorAndBattery.powerCruise.value/updatedSizing.motorAndBattery.nominalVoltage.value)/(updatedSizing.motorAndBattery.propullisiveEfficiency.value/100);
     updatedSizing.motorAndBattery.FlightTime.value=(updatedSizing.missionRequirement.range.value*1000/updatedSizing.operatingEnvironment.cruiseSpeed.value)/(3600);
     updatedSizing.motorAndBattery.rangeBatteryCapacity.value=(updatedSizing.motorAndBattery.FlightTime.value * updatedSizing.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(updatedSizing.motorAndBattery.maximumDischarge.value/100);
     updatedSizing.motorAndBattery.rangeCruiseSpeed.value=updatedSizing.missionRequirement.flightTime.value*60*60*updatedSizing.operatingEnvironment.cruiseSpeed.value/1000;
     updatedSizing.motorAndBattery.flightTimeBatteryCapacity.value=(updatedSizing.missionRequirement.flightTime.value * updatedSizing.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(updatedSizing.motorAndBattery.maximumDischarge.value/100);
     updatedSizing.motorAndBattery.capacityOfEachCell.value=updatedSizing.motorAndBattery.batteryCapacityParallel.value/updatedSizing.motorAndBattery.parallelCells.value;
     updatedSizing.motorAndBattery.cRating.value=updatedSizing.motorAndBattery.maxContinousCurrent.value/(updatedSizing.motorAndBattery.capacityOfEachCell.value/1000);





      let data={
            labels:this.props.label,
            datasets:[{
                label:'Variation of drag force with velocity',
                data:this.props.drag,
                backgroundColor:['rgba(162, 211, 235, 0.4)','red','blue','green','orange'],
                borderWidth:4,
                fill:true,
                radius:4,
                lineTension:0.5
            },
        ]
        }


        let labels=['0','5','10','15','20','25','30','35','40']
let velocity=[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35];
// let velocity=[0,5,10,15,20,25,30,35]
let cl=[];
let drag=[];

for(let i=0;i<velocity.length;i++){
    cl.push((state.mass.totalMass.value*state.operatingEnvironment.acceleration.value)/(1/2*state.operatingEnvironment.airDensity.value*Math.pow(velocity[i],2)*state.calculatedWing.wingArea.value))
    drag.push(1/2 *state.operatingEnvironment.airDensity.value*Math.pow(velocity[i],2)*state.calculatedWing.wingArea.value*(parasiticDrag+state.general.k.value*Math.pow(cl[i],2)))
}
console.log(cl,'arraycl')
console.log(drag,'arraydrag')
















import React, { useState, useEffect } from 'react';
import Header from './Header'
import { Paper, Typography, TextField, Container, Grid } from '@material-ui/core'
import InputUnit from './InputUnit';
import { useSelector } from 'react-redux'
import { useDispatch } from 'react-redux'
import { Button } from '../Button'
import * as actions from '../store/actions';

import { SizingProp, title } from '../data/data'
import Chart from './Chart';

const SizingInputContainer = (props) => {

    //Reducer data's

    const sizingPropsR = useSelector(({ reducer }) => reducer.sizingPropsR)

    const [state, setState] = useState(SizingProp)

    useEffect(() => {
        if (sizingPropsR) setState(sizingPropsR)
        // console.log(sizingPropsR)
    }, []);

    const submitHandler = (e) => {
        e.preventDefault()
        dispatch(actions.updateSizingPropValues(state))
        props.history.push('/')
    }
    //Dispatch

    const dispatch = useDispatch()

    // const sizingGetLocalStorage=()=>{
    //    return JSON.parse(localStorage.getItem('sizing'));
    // }
    // console.log(sizingGetLocalStorage,'retrive')


    let labels=['0','5','10','15','20','25','30','35','40']
    let velocity=[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35];
    // let velocity=[0,5,10,15,20,25,30,35]
    let cl=[];
    let drag=[];
    

    // dispatch({type:'sizing',data:{...data,value:e.target.value}})
    const updateState = (e, data, state, type) => {

        // console.log(state, type, "State")
        // console.log(e.target.value, "value")
        const newState = {
            ...state,
            [type]: {
                ...state[type],
                [data.name]: {
                    ...state[type][data.name],
                    value: e.target.value
                }
            }
        }
        return newState
    }

    const onChangeHandler = (e, data, type) => {
        // console.log(data, "data")
        let newState = {...state};
        newState = updateState(e, data, newState, type)


        // const updatedSizing={...state,[data.parent]:{...state[data.parent],[data.name]:{...state[data.parent][data.name],value:+e.target.value}}}
        // console.log(updatedSizing,"updatedSizing")
        // sizing.calculatedWing.wingArea.value=parseFloat(Math.pow(sizing.wing.span.value,2)/sizing.wing.aspectRatio.value).toPrecision(4);
        // sizing.calculatedWing.rootChord.value=parseFloat(2*sizing.calculatedWing.wingArea.value/(sizing.wing.span.value*(1+sizing.wing.tapperRatio.value))).toPrecision(4);


        const wingArea = Math.pow(newState.wing.span.value, 2) / newState.wing.aspectRatio.value;
        const wingRootChord = 2 * wingArea / (newState.wing.span.value * (1 + newState.wing.tapperRatio.value));
        const wingTipChord = (wingRootChord * newState.wing.tapperRatio.value);
        const meanAerodynamicChord = (1 + newState.wing.tapperRatio.value + Math.pow(newState.wing.tapperRatio.value, 2)) / (1 + newState.wing.tapperRatio.value) * 2 / 3 * wingRootChord;
        const horizontalSHT = newState.horizontalTail.cht.value * wingArea * meanAerodynamicChord / newState.horizontalTail.lht.value;
        const horizontalRootChord = (2 * horizontalSHT / newState.horizontalTail.span.value) / (1 + newState.horizontalTail.tapperRatio.value);
        const horizontalTipChord = horizontalRootChord * newState.horizontalTail.tapperRatio.value;
        const verticalSVT = wingArea * newState.wing.span.value * newState.verticalTail.cvt.value / newState.verticalTail.lvt.value;
        const verticalRootChord = (verticalSVT * 2 / newState.verticalTail.span.value) / (1 + newState.verticalTail.tapperRatio.value);
        const verticalTipChord = verticalRootChord * newState.verticalTail.tapperRatio.value;
        const massFraction = (newState.missionRequirement.payload.value + newState.mass.batteryMass.value) / newState.mass.totalMass.value * 100;

        const ostwaldEfficiency = 1 / (1 + newState.wing.inducedDragFactor.value)
        const k = 1 / (3.14 * ostwaldEfficiency * newState.wing.aspectRatio.value)
        const minDragAirspeed = Math.pow((2 * newState.mass.totalMass.value * newState.operatingEnvironment.acceleration.value / (newState.operatingEnvironment.airDensity.value * wingArea)), 0.5) * Math.pow((k / (newState.drag.wingZeroLiftDragCoefficient.value + newState.drag.fuselageDragCoefficient.value)), 0.25);
        const minPowerAirspeed = Math.pow(1 / (3), 0.25) * minDragAirspeed;
        const maxLiftCoefficient = newState.mass.totalMass.value * newState.operatingEnvironment.acceleration.value / (0.5 * newState.operatingEnvironment.airDensity.value * Math.pow(newState.operatingEnvironment.stallSpeed.value, 2) * wingArea);
        const designLiftCoefficient = newState.mass.totalMass.value * newState.operatingEnvironment.acceleration.value / (0.5 * newState.operatingEnvironment.airDensity.value * Math.pow(newState.operatingEnvironment.cruiseSpeed.value, 2) * wingArea);
        const inducedDragCoefficient = newState.general.k.value * Math.pow(newState.general.designLiftCoefficient.value, 2)
        const totalDragCoefficient = newState.drag.wingZeroLiftDragCoefficient.value + newState.drag.fuselageDragCoefficient.value + inducedDragCoefficient;
        const drag = (0.5 * newState.operatingEnvironment.airDensity.value * Math.pow(newState.operatingEnvironment.cruiseSpeed.value, 2) * wingArea * (totalDragCoefficient) / newState.operatingEnvironment.acceleration.value)
        const liftToDragRatio = designLiftCoefficient / inducedDragCoefficient;
        const motorMaxPower = newState.mass.totalMass.value * newState.motorAndBattery.powerToWeightRatio.value;
        const motorPowerCruise = newState.general.drag.value * newState.operatingEnvironment.acceleration.value * newState.operatingEnvironment.cruiseSpeed.value;
        const motorCurrentCruise = (motorPowerCruise / newState.motorAndBattery.nominalVoltage.value) / (newState.motorAndBattery.propullisiveEfficiency.value / 100);
        const flightTime = (newState.missionRequirement.range.value * 1000 / newState.operatingEnvironment.cruiseSpeed.value) / (3600);
        const rangeBatteryCapacity = (flightTime * motorCurrentCruise / Math.pow(10, -3)) / (newState.motorAndBattery.maximumDischarge.value / 100);
        const rangeCruiseSpeed = newState.missionRequirement.flightTime.value * 60 * 60 * newState.operatingEnvironment.cruiseSpeed.value / 1000;
        const flightTimeBatteryCapacity = (newState.motorAndBattery.currentCruise.value * newState.missionRequirement.flightTime.value * 1000) / newState.motorAndBattery.maximumDischarge.value / 100;
        const capacityOfEachCell = newState.motorAndBattery.batteryCapacityParallel.value / newState.motorAndBattery.parallelCells.value;
        const cRating = newState.motorAndBattery.maxContinousCurrent.value / (capacityOfEachCell / 1000);


        //   newState.calculatedWing.wing.value=wingArea ;
        newState.calculatedWing.wingArea.value = wingArea
        newState.calculatedWing.rootChord.value = wingRootChord;
        newState.calculatedWing.tipChord.value = wingTipChord;
        newState.calculatedWing.meanAerodynamicChord.value = meanAerodynamicChord;
        newState.calculatedHorizontalTail.sht.value = horizontalSHT;
        newState.calculatedHorizontalTail.rootChord.value = horizontalRootChord;
        newState.calculatedHorizontalTail.tipChord.value = horizontalTipChord;
        newState.calculatedVerticalTail.svt.value = verticalSVT;
        newState.calculatedVerticalTail.rootChord.value = verticalRootChord;
        newState.calculatedVerticalTail.tipChord.value = verticalTipChord;
        newState.general.massFraction.value = massFraction;
        newState.general.ostwaldEfficiency.value = ostwaldEfficiency;
        newState.general.k.value = k;
        newState.general.minDragAirspeed.value = minDragAirspeed;
        newState.general.minPowerAirspeed.value = minPowerAirspeed
        newState.general.maxLiftCoefficient.value = maxLiftCoefficient
        newState.general.designLiftCoefficient.value = designLiftCoefficient
        newState.general.inducedDragCoefficient.value = inducedDragCoefficient
        newState.general.totalDragCoefficient.value = totalDragCoefficient
        newState.general.drag.value = drag
        newState.general.liftToDragRatio.value = liftToDragRatio
        newState.motorAndBattery.maxPower.value = motorMaxPower
        newState.motorAndBattery.powerCruise.value = motorPowerCruise
        newState.motorAndBattery.currentCruise.value = motorCurrentCruise
        newState.motorAndBattery.FlightTime.value = flightTime
        newState.motorAndBattery.rangeBatteryCapacity.value = rangeBatteryCapacity
        newState.motorAndBattery.rangeCruiseSpeed.value = rangeCruiseSpeed
        newState.motorAndBattery.capacityOfEachCell.value = capacityOfEachCell
        newState.motorAndBattery.cRating.value = cRating;

        //   newState.calculatedWing.wing.value=Math.pow(newState.wing.span.value,2)/newState.wing.aspectRatio.value;
        //  newState.calculatedWing.rootChord.value=2*newState.calculatedWing.wingArea.value/(newState.wing.span.value*(1+newState.wing.tapperRatio.value));
        //  newState.calculatedWing.tipChord.value=(newState.calculatedWing.rootChord.value*newState.wing.tapperRatio.value);
        //   newState.calculatedWing.meanAerodynamicChord.value=(1+newState.wing.tapperRatio.value+Math.pow(newState.wing.tapperRatio.value,2))/(1+newState.wing.tapperRatio.value)*2/3*newState.calculatedWing.rootChord.value;
        //  newState.horizontalTail.sht.value=newState.horizontalTail.cht.value*newState.calculatedWing.wingArea.value*newState.calculatedWing.meanAerodynamicChord.value/newState.horizontalTail.lht.value;
        //   newState.calculatedHorizontalTail.rootChord.value=(2*newState.calculatedHorizontalTail.sht.value/newState.horizontalTail.span.value)/(1+newState.horizontalTail.tapperRatio.value);
        //   newState.calculatedHorizontalTail.tipChord.value=newState.calculatedHorizontalTail.rootChord.value*newState.horizontalTail.tapperRatio.value;
        //   console.log(newState.calculatedVerticalTail.svt.value=newState.calculatedWing.wingArea.value*newState.wing.span.value*newState.verticalTail.cvt.value/newState.verticalTail.lvt.value);
        //   newState.calculatedVerticalTail.rootChord.value=(newState.calculatedVerticalTail.svt.value*2/newState.verticalTail.span.value)/(1+newState.verticalTail.tapperRatio.value);
        //   newState.calculatedVerticalTail.tipChord.value=newState.calculatedVerticalTail.rootChord.value*newState.verticalTail.tapperRatio.value;
        //   console.log(newState.general.massFraction.value=(newState.missionRequirement.payload.value+newState.mass.batteryMass.value)/newState.mass.totalMass.value*100,'massfra');
        //   newState.general.ostwaldEfficiency.value=1/(1+newState.wing.inducedDragFactor.value)
        //   newState.general.k.value=1/(3.14*newState.general.ostwaldEfficiency.value*newState.wing.aspectRatio.value)
        //   newState.general.minDragAirspeed.value=Math.pow((2*newState.mass.totalMass.value*newState.operatingEnvironment.acceleration.value/(newState.operatingEnvironment.airDensity.value*newState.calculatedWing.wingArea.value)),0.5)*Math.pow((newState.general.k.value/(newState.drag.wingZeroLiftDragCoefficient.value+newState.drag.fuselageDragCoefficient.value)),0.25);
        //   newState.general.minPowerAirspeed.value=Math.pow(1/(3),0.25)*newState.general.minDragAirspeed.value;
        //   newState.general.maxLiftCoefficient.value=newState.mass.totalMass.value*newState.operatingEnvironment.acceleration.value/(0.5*newState.operatingEnvironment.airDensity.value*Math.pow(newState.operatingEnvironment.stallSpeed.value,2)*newState.calculatedWing.wingArea.value);
        //   newState.general.designLiftCoefficient.value=newState.mass.totalMass.value*newState.operatingEnvironment.acceleration.value/(0.5*newState.operatingEnvironment.airDensity.value*Math.pow(newState.operatingEnvironment.cruiseSpeed.value,2)*newState.calculatedWing.wingArea.value);
        //   newState.general.inducedDragCoefficient.value=newState.general.k.value*Math.pow(newState.general.designLiftCoefficient.value,2)
        //   newState.general.totalDragCoefficient.value=newState.drag.wingZeroLiftDragCoefficient.value+newState.drag.fuselageDragCoefficient.value+newState.general.inducedDragCoefficient.value;
        //   newState.general.drag.value=(0.5*newState.operatingEnvironment.airDensity.value*Math.pow(newState.operatingEnvironment.cruiseSpeed.value,2)*newState.calculatedWing.wingArea.value*(newState.general.totalDragCoefficient.value)/newState.operatingEnvironment.acceleration.value)
        //   newState.general.liftToDragRatio.value=newState.general.designLiftCoefficient.value/newState.general.inducedDragCoefficient.value;
        //   newState.motorAndBattery.maxPower.value=newState.mass.totalMass.value*newState.motorAndBattery.powerToWeightRatio.value;
        //   newState.motorAndBattery.powerCruise.value=newState.general.drag.value*newState.operatingEnvironment.acceleration.value*newState.operatingEnvironment.cruiseSpeed.value;
        //   newState.motorAndBattery.currentCruise.value=(newState.motorAndBattery.powerCruise.value/newState.motorAndBattery.nominalVoltage.value)/(newState.motorAndBattery.propullisiveEfficiency.value/100);
        //   newState.motorAndBattery.FlightTime.value=(newState.missionRequirement.range.value*1000/newState.operatingEnvironment.cruiseSpeed.value)/(3600);
        //   newState.motorAndBattery.rangeBatteryCapacity.value=(newState.motorAndBattery.FlightTime.value * newState.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(newState.motorAndBattery.maximumDischarge.value/100);
        //   newState.motorAndBattery.rangeCruiseSpeed.value=newState.missionRequirement.flightTime.value*60*60*newState.operatingEnvironment.cruiseSpeed.value/1000;
        //   newState.motorAndBattery.flightTimeBatteryCapacity.value=(newState.missionRequirement.flightTime.value * newState.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(newState.motorAndBattery.maximumDischarge.value/100);
        //   newState.motorAndBattery.capacityOfEachCell.value=newState.motorAndBattery.batteryCapacityParallel.value/newState.motorAndBattery.parallelCells.value;
        //   newState.motorAndBattery.cRating.value=newState.motorAndBatty.maxContinousCurrent.value/(newState.motorAndBattery.capacityOfEachCell.value/1000);



        setState(newState)
    }
    const parasiticDrag=state.drag.wingZeroLiftDragCoefficient.value+state.drag.fuselageDragCoefficient.value;
    console.log(parasiticDrag,'drag')

    for(let i=0;i<velocity.length;i++){
        cl.push((state.mass.totalMass.value*state.operatingEnvironment.acceleration.value)/(1/2*state.operatingEnvironment.airDensity.value*Math.pow(velocity[i],2)*state.calculatedWing.wingArea.value))
        drag.push(1/2 *state.operatingEnvironment.airDensity.value*Math.pow(velocity[i],2)*state.calculatedWing.wingArea.value*(state.drag.wingZeroLiftDragCoefficient.value+state.drag.fuselageDragCoefficient.value+state.general.k.value*Math.pow(cl[i],2)))
    }
    console.log(cl,'arraycl')
console.log(drag,'arraydrag')


    // localStorage.setItem('newState',JSON.stringify(Sizing));

    // console.log(state, "state")

    let sizingArray = []
    for (let key in state) {
        let innerArray = []
        for (let key2 in state[key]) {
            innerArray.push({ data: state[key][key2] })
        }
        sizingArray.push({ data: innerArray, title: title[key] })
    }

    // console.log("mainarray", sizingArray)
    return (
        <>
            <Header header='Sizing Study' />
            <Grid container>
                <div >
                    <Grid container>
                        {sizingArray ? (
                            sizingArray.map((parent, key) => {
                                return (

                                    <Grid key={key} items xs={12} md={6} style={{ margin: '20px 0' }} >
                                        <Paper elevation={4} className="paper" style={{ padding: '20px 30px', marginLeft: ' 20px', marginRight: '10px' }}>
                                            <div style={{ marginTop: '0px' }}>
                                                <Typography variant='h5' style={{ marginBottom: '12px', textAlign: 'center' }}>{parent.title}</Typography>
                                                <div style={{ flexGrow: 1 }}>
                                                    <Grid item xs={12}>

                                                        {parent.data.map((child, index) => {
                                                            return (
                                                                <InputUnit key={child.data.name} id={child.data.name} data={child.data} onChange={(e) => onChangeHandler(e, child.data, child.data.parent)} />
                                                            )
                                                        })}
                                                    </Grid>
                                                </div>
                                            </div>
                                        </Paper>
                                    </Grid>


                                )
                            })
                        ) : ''}
                    </Grid>
                    <Button text='Prev' submitHandler={(e) => submitHandler(e)} />
                    <Chart cl={cl} drag={drag} velocity={velocity} labels={labels} />
                </div>
            </Grid>
        </>
    )
}
export default SizingInputContainer

const header={
    header:'header'
}

const setup = (props = {}, state = null) => {
    return (shallow( < Header {...props}  />)
    )
}

const findByTestAttr=(wrapper, val)=>{
    return wrapper.find(`[data-test='${val}']`)
}



it('should render title name in Navbar',()=>{
    const wrapper=setup(header)
    const header=findByTestAttr(wrapper,"header")
    // const wrapper=shallow(<Header header="header"/>);
    // const {getByTestId}=render(<Header/>);
    const headerCheck=header.text();
    // const header = wrapper.find('[data-testid="header"]').text();

    // const header=getByTestId('header')
    // const result=header.text();
    expect(header).toBe('header');
})


"jest": {
    "collectCoverage": true,
    "coverageReporters": [
      "lcov"
    ],
    "coverageDirectory": "./output/code-coverage/"
  },

      "coverage": "jest --collect-coverage"

    "jest": "^27.0.4"


 <Route path="/motorandpropeller" render={()=>(<MotorAndPropellerInputContainer/>)} />
        {/* <Route path="/sizing" render={()=>(<SizingInputContainer/>)} /> */}
        <Route path="/sizing" component="./app/global/SizingInputContainer.js" />
        <Route exact path="/" render={()=>(<MotorAndPropellerInputContainer/>)}/>



          newState.calculatedWing.wingArea.value=wingAreaCalc(newState)
         newState.calculatedWing.rootChord.value=2*newState.calculatedWing.wingArea.value/(newState.wing.span.value*(1+newState.wing.tapperRatio.value));
         newState.calculatedWing.tipChord.value=(newState.calculatedWing.rootChord.value*newState.wing.tapperRatio.value);
          newState.calculatedWing.meanAerodynamicChord.value=(1+newState.wing.tapperRatio.value+Math.pow(newState.wing.tapperRatio.value,2))/(1+newState.wing.tapperRatio.value)*2/3*newState.calculatedWing.rootChord.value;
         newState.calculatedHorizontalTail.sht.value=newState.horizontalTail.cht.value*newState.calculatedWing.wingArea.value*newState.calculatedWing.meanAerodynamicChord.value/newState.horizontalTail.lht.value;
          newState.calculatedHorizontalTail.rootChord.value=(2*newState.calculatedHorizontalTail.sht.value/newState.horizontalTail.span.value)/(1+newState.horizontalTail.tapperRatio.value);
          newState.calculatedHorizontalTail.tipChord.value=newState.calculatedHorizontalTail.rootChord.value*newState.horizontalTail.tapperRatio.value;
        // This may have a problem  console.log(newState.calculatedVerticalTail.svt.value=newState.calculatedWing.wingArea.value*newState.wing.span.value*newState.verticalTail.cvt.value/newState.verticalTail.lvt.value);
        newState.calculatedVerticalTail.svt.value=newState.calculatedWing.wingArea.value*newState.wing.span.value*newState.verticalTail.cvt.value/newState.verticalTail.lvt.value;
          newState.calculatedVerticalTail.rootChord.value=(newState.calculatedVerticalTail.svt.value*2/newState.verticalTail.span.value)/(1+newState.verticalTail.tapperRatio.value);
          newState.calculatedVerticalTail.tipChord.value=newState.calculatedVerticalTail.rootChord.value*newState.verticalTail.tapperRatio.value;
        //  This may have a problem console.log(newState.general.massFraction.value=(newState.missionRequirement.payload.value+newState.mass.batteryMass.value)/newState.mass.totalMass.value*100,'massfra');
        newState.general.massFraction.value=(newState.missionRequirement.payload.value+newState.mass.batteryMass.value)/newState.mass.totalMass.value*100;
          newState.general.ostwaldEfficiency.value=1/(1+newState.wing.inducedDragFactor.value)
          newState.general.k.value=1/(3.14*newState.general.ostwaldEfficiency.value*newState.wing.aspectRatio.value)
          newState.general.minDragAirspeed.value=Math.pow((2*newState.mass.totalMass.value*newState.operatingEnvironment.acceleration.value/(newState.operatingEnvironment.airDensity.value*newState.calculatedWing.wingArea.value)),0.5)*Math.pow((newState.general.k.value/(newState.drag.wingZeroLiftDragCoefficient.value+newState.drag.fuselageDragCoefficient.value)),0.25);
        //   console.log(newState.mass.totalMass.value,newState.operatingEnvironment.acceleration.value,newState.operatingEnvironment.airDensity.value,newState.calculatedWing.wingArea.value,newState.general.k.value,newState.drag.fuselageDragCoefficient.value,"mindrag")
          newState.general.minPowerAirspeed.value=Math.pow(1/(3),0.25)*newState.general.minDragAirspeed.value;
          newState.general.maxLiftCoefficient.value=newState.mass.totalMass.value*newState.operatingEnvironment.acceleration.value/(0.5*newState.operatingEnvironment.airDensity.value*Math.pow(newState.operatingEnvironment.stallSpeed.value,2)*newState.calculatedWing.wingArea.value);
          newState.general.designLiftCoefficient.value=newState.mass.totalMass.value*newState.operatingEnvironment.acceleration.value/(0.5*newState.operatingEnvironment.airDensity.value*Math.pow(newState.operatingEnvironment.cruiseSpeed.value,2)*newState.calculatedWing.wingArea.value);
          newState.general.inducedDragCoefficient.value=newState.general.k.value*Math.pow(newState.general.designLiftCoefficient.value,2)
          newState.general.totalDragCoefficient.value=newState.drag.wingZeroLiftDragCoefficient.value+newState.drag.fuselageDragCoefficient.value+newState.general.inducedDragCoefficient.value;
          newState.general.drag.value=(0.5*newState.operatingEnvironment.airDensity.value*Math.pow(newState.operatingEnvironment.cruiseSpeed.value,2)*newState.calculatedWing.wingArea.value*(newState.general.totalDragCoefficient.value)/newState.operatingEnvironment.acceleration.value)
          newState.general.liftToDragRatio.value=newState.general.designLiftCoefficient.value/newState.general.inducedDragCoefficient.value;
          newState.motorAndBattery.maxPower.value=newState.mass.totalMass.value*newState.motorAndBattery.powerToWeightRatio.value;
          newState.motorAndBattery.powerCruise.value=newState.general.drag.value*newState.operatingEnvironment.acceleration.value*newState.operatingEnvironment.cruiseSpeed.value;
          newState.motorAndBattery.currentCruise.value=(newState.motorAndBattery.powerCruise.value/newState.motorAndBattery.nominalVoltage.value)/(newState.motorAndBattery.propullisiveEfficiency.value/100);
          newState.motorAndBattery.FlightTime.value=(newState.missionRequirement.range.value*1000/newState.operatingEnvironment.cruiseSpeed.value)/(3600);
          newState.motorAndBattery.rangeBatteryCapacity.value=(newState.motorAndBattery.FlightTime.value * newState.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(newState.motorAndBattery.maximumDischarge.value/100);
          newState.motorAndBattery.rangeCruiseSpeed.value=newState.missionRequirement.flightTime.value*60*60*newState.operatingEnvironment.cruiseSpeed.value/1000;
          newState.motorAndBattery.flightTimeBatteryCapacity.value=(newState.missionRequirement.flightTime.value * newState.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(newState.motorAndBattery.maximumDischarge.value/100);
          newState.motorAndBattery.capacityOfEachCell.value=newState.motorAndBattery.batteryCapacityParallel.value/newState.motorAndBattery.parallelCells.value;
          newState.motorAndBattery.cRating.value=newState.motorAndBattery.maxContinousCurrent.value / (newState.motorAndBattery.batteryCapacityParallel.value / newState.motorAndBattery.parallelCells.value / 1000)

